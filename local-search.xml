<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>事务之MySQL与Spring</title>
    <link href="/2022/07/27/%E4%BA%8B%E5%8A%A1%E4%B9%8BMySQL%E4%B8%8ESpring/"/>
    <url>/2022/07/27/%E4%BA%8B%E5%8A%A1%E4%B9%8BMySQL%E4%B8%8ESpring/</url>
    
    <content type="html"><![CDATA[<h3 id="前请提要"><a href="#前请提要" class="headerlink" title="前请提要"></a>前请提要</h3><p>事务的ACID特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）<br>事务隔离级别（读未提交，读已提交，可重复读，序列化）<br>CAP理论：一致性（Consistency）、可用性（Availability）、分区容忍性（Partition Tolerance）</p><h2 id="MySQL事务实现原理"><a href="#MySQL事务实现原理" class="headerlink" title="MySQL事务实现原理"></a>MySQL事务实现原理</h2><h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><p>负责原子性与持久性，记载对磁盘上数据进行的修改操作<br>作用：恢复提交后的物理数据页<br>构成：<br>日志缓冲（内存） – 易失<br>重做日志文件（磁盘）–  持久化 不易失<br>刷盘规则：<br>    （1）开启事务，发出提交事务指令后是否刷新日志由innodb_flush_log_at_trx_commit决定，默认1（每次提交事务都将日志缓冲中日志写入OS buffer，并且调用fsync(）写入磁盘文件，不会丢失数据）<br>0、1、2的值影响写入OS buffer与写入磁盘文件是否需要隔1s<br>（2）按频率刷新。刷新频率由innodb_flush_log_at_timeout决定，默认1s<br>（3）Log Buffer使用内存&gt;50% 触发刷盘操作<br>（4）chechpoint 一定程度上代表了刷鞋到磁盘时日志所处LSN位置（Long sequence number）</p><h3 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h3><p>作用：回滚事务和多版本并发事务–MVCC机制<br>undo log也会产生redo log保证完整性与可靠性<br>存储：段segment，存放在共享数据表空间，默认ibdata1文件<br>undo log实现MVCC：<br>两个隐藏列：行的创建版本；行删除版本<br>可重复读下增删查改：<br>select:只查找版本号&lt;=当前事务版本号的数据<br>insert：将当前事务版本号保存为当前行创建版本号<br>delete: 当前事务版本号保存为删除的数据行版本号，作为行删除标识<br>update:innodb将待修改的行赋值为新行，当前事务版本号保存为新数据行的创建版本号，<strong>同时保存当前事务版本号为原来数据行删除版本号</strong><br>实际innodb实现上 每行数据后面添加了三个字段：6字节事务id,7字节回滚指针,6字节DB_ROW_ID</p><h3 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h3><p>属于MySQL的日志(redo log是innodb特有)  二进制日志<br>以事件形式记录所有数据库表结构变更以及表数据变更的二进制日志<br>使用场景：主从复制；数据恢复<br>记录模式:row\statement\mixed</p><h3 id="MySQL事务执行流程"><a href="#MySQL事务执行流程" class="headerlink" title="MySQL事务执行流程"></a>MySQL事务执行流程</h3><img src="/project/2022/07/27/%E4%BA%8B%E5%8A%A1%E4%B9%8BMySQL%E4%B8%8ESpring/1655400261761-acb3d305-97db-41c9-ba16-aa57cb63964f.jpeg" style="zoom:80%;"><h3 id="事务恢复流程"><a href="#事务恢复流程" class="headerlink" title="事务恢复流程"></a>事务恢复流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29005494/1655400240625-491c357b-c3f6-4866-9734-c977a5cc9082.jpeg"></p><h3 id="MySQL中XA事务"><a href="#MySQL中XA事务" class="headerlink" title="MySQL中XA事务"></a>MySQL中XA事务</h3><p>XA(eXtended Architecture)是指由X/Open 组织提出的分布式交易处理的规范。XA 是一个分布式事务协议,由Tuxedo 提出,所以分布式事务也称为XA 事务。<br>本质上基于两阶段提交，有一个事务管理器，一个或多个资源管理器和一个应用程序组成<br>MySQL中通过show engiens命令查看存储引擎是否支持XA事务<br>可以通过JDBC操作MySQL事务但较为繁琐</p><h2 id="Spring-事务实现原理"><a href="#Spring-事务实现原理" class="headerlink" title="Spring 事务实现原理"></a>Spring 事务实现原理</h2><p>本质上是对数据库事务的进一步封装<br>使用spring事务则不用JDBC手动开启、提交、回滚事务<br>通过注解实现</p><h3 id="三大接口"><a href="#三大接口" class="headerlink" title="三大接口"></a>三大接口</h3><p>Platform TransactionManager：为Hibernate、MyBatis、JTA等持久化框架提供了事务管理器<br>TransactionDefinition：主要定义了与事务相关的方法，表示事务属性的常量值等。部分事务属性的常量与Propagation枚举类中的事务传播类型相对应<br>TransactionStatus：存储事务执行状态，并定义一组方法来判断或读取事务状态信息</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>ISOLATION_DEFAULT：默认。直接使用数据库默认的事务隔离级别<br>ISOLATION_READ_UNCOMMITTED：最低，会产生脏读、不可重复读和幻读问题。相当于MySQL的UNCOMMITTED_READ<br>ISOLATION_READ_COMMITTED：存在不可重复读和幻读问题。相当于COMMITTED_READ<br>ISOLATION_REPEATABLE_READ：存在幻读问题。相当于REPEATABLE_READ<br>ISOLATION_SERIALIZABLE：事务只能按特定顺序执行，相当于SERIALIZABLE</p><p>ps：不可重复读关注修改，幻读关注增删</p><h3 id="传播机制"><a href="#传播机制" class="headerlink" title="传播机制"></a>传播机制</h3><p>加粗为常用事务类型<br>支持当前事务：<br><strong>REQUIRED：默认</strong><br>SUPPORTS：外部不存在事务时，不会开启新的事物，外部存在事务时，将其加入外部事物<br>MANDATORY：具备强制性，当前操作必须存在事务，不存在则抛出异常</p><p>不支持当前事务：<br><strong>REQUIRES_NEW：总是创建新的事务执行，适用于不受外层方法事务影响的场景如记录事务日志等操作</strong><br><strong>NOT_SUPPORTED：适用于发送提示信息、邮件等不影响系统的主体业务逻辑，即使操作失败也不应该对主体逻辑产生影响，不能使主题逻辑的事务回滚</strong><br>NEVER：当前操作存在事务则抛出异常<br>嵌套：<br>NESTED：封装事务存在，并且外部事物抛出异常回滚，内层事务必回滚。内层事务回滚则并不影响外层事务的提交与回滚。如果封装事务不存在则按REQUIED事务传播类型执行</p><h3 id="失效场景"><a href="#失效场景" class="headerlink" title="失效场景"></a>失效场景</h3><p>数据库不支持事务<br>事务方法未被Spring管理<br>方法没有被public修饰<br>同一类中方法调用<br>未配置事务管理器<br>方法的事务传播类型不支持事务<br>不正确的捕获异常<br>标注错误异常类型</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解分布式事务-原理与实战》  肖宇、冰河著</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PR流程</title>
    <link href="/2022/07/27/PR%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/07/27/PR%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>ps: 本次操作以Seata为源仓库</p><h3 id="三阶段"><a href="#三阶段" class="headerlink" title="三阶段"></a>三阶段</h3><p><img src="https://cdn.jsdelivr.net/gh/SherZhou/pic_source/img/1658886093327-e4f54f3e-47e6-494f-acfb-ed3bb0ea768e.jpeg" alt="img"></p><h3 id="准备仓库"><a href="#准备仓库" class="headerlink" title="准备仓库"></a>准备仓库</h3><h4 id="fork项目"><a href="#fork项目" class="headerlink" title="fork项目"></a>fork项目</h4><p>进入源项目页面，点击右上角Fork按钮</p><p><img src="https://cdn.jsdelivr.net/gh/SherZhou/pic_source/img/1658888621847-879f79fc-a17c-499b-b5ca-42006d34ddbf-16588931386535-165889350667013.png"></p><p>会自动生成以自己名称命名的项目</p><p><img src="/project/2022/07/27/PR%E6%B5%81%E7%A8%8B/1658888505200-c951bc7d-18cd-48fe-89f6-c557a45ed51d-165889350975115.png"></p><h4 id="clone到本地"><a href="#clone到本地" class="headerlink" title="clone到本地"></a>clone到本地</h4><p>即将自己名称下的项目下载到本地<br><img src="/PR%E6%B5%81%E7%A8%8B.assets/1658889063492-78b17270-fd3b-468f-aced-3199adb2872a.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/(your_github_name)/(upstream_project_name).git<br>cd upstream_project_name<br></code></pre></td></tr></table></figure><p><img src="/project/2022/07/27/PR%E6%B5%81%E7%A8%8B/1658889091140-634fb3a9-e8c5-4ba2-b05a-c635a40b9449-16588932048249-165889351770819.png"></p><h4 id="设置remote"><a href="#设置remote" class="headerlink" title="设置remote"></a>设置remote</h4><p>与源远程仓库建立联系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add upstream https://github.com/...(source_project_address)<br></code></pre></td></tr></table></figure><p><img src="/project/2022/07/27/PR%E6%B5%81%E7%A8%8B/1658889446085-e867c55a-dcd5-4b78-af41-58631e011463.png"><br>查看联系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote -v<br></code></pre></td></tr></table></figure><p><img src="/project/2022/07/27/PR%E6%B5%81%E7%A8%8B/1658889385032-1ada811c-56dd-4d54-a3da-533cd3544e06.png"><br>可以看到自己的仓库地址(origin)与源仓库地址(upstream)</p><h4 id="编译项目（非必须）"><a href="#编译项目（非必须）" class="headerlink" title="编译项目（非必须）"></a>编译项目（非必须）</h4><p>编译并安装所有模块到Maven本地仓库缓存，同时会生成ANTLR.g4语法文件对应的解析器Java类，这样在IDE就不会有相关编译错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd upstream_project_name<br><span class="hljs-meta prompt_">#</span><span class="language-bash">我一般只跳过checkstyle和Tests</span><br>mvn clean install -Dmaven.javadoc.skip=true -Dcheckstyle.skip=true -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests -Prelease<br></code></pre></td></tr></table></figure><p>以后从源文件拉去最新代码并新建分支时可能会遇到类似解析器编译错误，可以重新运行该命令来解决问题。</p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>用于开发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">切换本地分支（切换分支到develop）</span><br>git checkout upstream develop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将更新源远程repo(upstream)所包含develop分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中</span><br>git fetch upstream<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">改变基底，类似与git merge 但源仓库有最新提交时两者间有区别</span><br>git rebase upstream/master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将代码push到自己名称下仓库(origin)的master分支</span><br>git push origin master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看当前所在分支</span><br>git branch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建新的分支</span><br>git checkout -b your_branch<br></code></pre></td></tr></table></figure><p>PR会按照squash方式进行merge。如果不创建新分支，本地和远程的提交记录将不能保持同步<br>ps: 方便id显示在contributor列表中可以做以下设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global your.name&quot;username&quot;<br>git congig --global your.email&quot;xxx@mail.com&quot;<br></code></pre></td></tr></table></figure><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="修改代码，保存修改，推送到自己的远程仓库"><a href="#修改代码，保存修改，推送到自己的远程仓库" class="headerlink" title="修改代码，保存修改，推送到自己的远程仓库"></a>修改代码，保存修改，推送到自己的远程仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">保存修改到暂存区</span><br>git add <br><span class="hljs-meta prompt_">#</span><span class="language-bash">将暂存区内容添加到本地仓库</span><br>git commit -m&quot;commit log&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">推送到自己的远程仓库</span><br>git push origin your_branch<br></code></pre></td></tr></table></figure><h3 id="提交PR"><a href="#提交PR" class="headerlink" title="提交PR"></a>提交PR</h3><p>发出一个pull request到 upstream develop分支<br><img src="/project/2022/07/27/PR%E6%B5%81%E7%A8%8B/1658891906292-4ef51083-3d12-4ca8-afe3-6c7f3c17efe1.png"><br>填写标题和内容点击确认<br>之后导师会进行代码复核工作，满意后导师会将其合并到源分支</p><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout master<br>git branch -d your_branch<br>git remote prune origin #如果已经在GitHub PR页面删除了分支，否则可以执行下面命令删除<br>git push origin --delete your_branch<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode amateur</title>
    <link href="/2022/06/07/leetcode-amateur/"/>
    <url>/2022/06/07/leetcode-amateur/</url>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><p>stringBuilder sb<br>Sb.charAt()<br>Sb.setChatAt(位置，值)</p><p>或者 char[] ch = s.toCharArray()<br>转换为数组交换问题<br>Stack –基于vector–peek push pop<br>Queue –基于 linkedList–  peek offer poll</p><p>关于StringBuilder与StringBuffer<br>Builder 更快 适用于单线程<br>Buffer线程安全 适用于多线程</p><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>要分析好不匹配的情况<br>左/右括号<br>匹配错误<br>使用deque  – 基于queue–实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，<br>//ArrayDeque会比LinkedList在除了删除元素这一点外会快一点<br>//参考：<a href="https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist">https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist</a><br>peek</p><p>!!!字符串数组 ch.length<br>字符串 s.length()<br>集合类 .size()<br>滑动窗口最大值 双指针不行吗</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
