<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Notes</title>
    <link href="/2022/06/07/readingNotes/"/>
    <url>/2022/06/07/readingNotes/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="判断对象”生死“"><a href="#判断对象”生死“" class="headerlink" title="判断对象”生死“"></a>判断对象”生死“</h3><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>应用计数法–循环引用问题–&gt;可达性分析算法<br>实现：通过一系列GC Roots通过引用链。当Object到GC Roots不可达则需回收</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>强引用、软引用、若引用、虚引用</p><h4 id="方法区-无用的类"><a href="#方法区-无用的类" class="headerlink" title="方法区-无用的类"></a>方法区-无用的类</h4><p>ps: 元空间–永久代–方法区落地实现<br>所有实例已被回收（Java堆中不存在该类实例）<br>加载该类的ClassLoader已被回收<br>该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h4><p>不足：<br>效率低–复制算法<br>空间碎片多</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>内存容量等量划分为两块，一次对整个半区进行内存回收<br>只要移动堆顶指针，按顺序分配内存<br>缺点：内存缩小为原来一半（改进1：不均分）<br>对象存活率较高时要进行较多复制操作（改进：标记-整理算法)</p><h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h4><p>不是对可回收对象进行清理，而是让所有存活对象向一端移动，然后清理端边界之外的内存<br>（先挪动，再统一清理）</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>只是根据对象存活周期的不同将内存划分为几块。<br>一般是把Java堆分为新生代和老年代。<br>新生代：每次垃圾收集时都发现有大批对象死去，只有少量存活。<br>选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。<br>老年代：对象存活率高、没有额外空间对它进行分配担保，<br>就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>枚举GC ROOT<br>设判安全点、安全区</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>单线程–收集时暂停其他所有的工作线程 直至收集结束</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>Serial多线程版本</p><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>新生代收集器–使用复制算法<br>关注点<br>CMS等：缩短用户线程停顿时间–响应好<br>Parallel Scanvenge:达到一个可控的吞吐量–高效利用CPU</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>Concurrent Mark Sweep<br>过程：<br>初始标记–&gt;并发标记–&gt;重新标记–&gt;并发清除<br>1、3步需“stop the world”<br>2、4耗时长但可以与用户线程一起工作<br>缺点：<br>对CPU资源敏感<br>无法处理浮动垃圾（并发清理阶段用户线程产生的新垃圾，CMS无法在当次收集中处理掉）<br>基于标记–清除算法 ，会产生大量空间碎片–内存整理仍是单线程</p><h4 id="G1收集器☆"><a href="#G1收集器☆" class="headerlink" title="G1收集器☆"></a>G1收集器☆</h4><p>面向服务端应用<br>初始标记–&gt;并发标记–&gt;最终标记–&gt;筛选回收<br>垃圾收集相关参数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29005494/1653547210249-36327a5b-1805-42ef-a05d-488e5dde67ff.png#clientId=uc173d41e-4a84-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=550&id=u05fa212e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=825&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&size=415424&status=done&style=none&taskId=u08f04b08-62ca-46f6-b9e1-358f7198230&title=&width=577.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29005494/1654276967991-b1262c7a-ce8d-495a-bd1b-b964678f78f9.png#clientId=u34aec54a-525a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u3f4c24f3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100834&status=done&style=none&taskId=u0a6df56e-b014-4ffb-b950-2c5ec0d9d27&title=&width=424.6666666666667" alt="image.png"></p><h2 id="ON-JAVA"><a href="#ON-JAVA" class="headerlink" title="ON JAVA"></a>ON JAVA</h2><p>单继承结构的优势：所有类最终都属于同一个基类；使得垃圾收集器的实现更容易<br>Arrays.asList() 方法接受一个数组或是逗号分隔的元素列表（使用可变参数）， 并将其转换为 **List **对象。但这里底层是数组，尝试在该List上调用add() 或 remove()会在运行时报“Unsupported Operation”<br>Collections.addAll() 方法接受一个 **Collection **对象，以 及一个数组或是一个逗号分隔的列表，将其中元素添加到 **Collection **中。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29005494/1654504936769-e0d64bb1-050d-4dce-915f-645f07ccf78b.jpeg"><br>iterator只能单向移动(hasNext)<br>而ListIterator可以双向移动<br>Queue在LinkedList的基础上添加了element(),offer(),peek(),poll()和remove()方法<br>Java6中添加了ArrayDeque 其中包含直接实现堆栈功能的方法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode amateur</title>
    <link href="/2022/06/07/leetcode-amateur/"/>
    <url>/2022/06/07/leetcode-amateur/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><p>stringBuilder sb<br>Sb.charAt()<br>Sb.setChatAt(位置，值)</p><p>或者 char[] ch = s.toCharArray()<br>转换为数组交换问题<br>Stack –基于vector–peek push pop<br>Queue –基于 linkedList–  peek offer poll</p><p>关于StringBuilder与StringBuffer<br>Builder 更快 适用于单线程<br>Buffer线程安全 适用于多线程</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>要分析好不匹配的情况<br>左/右括号<br>匹配错误<br>使用deque  – 基于queue–实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，<br>//ArrayDeque会比LinkedList在除了删除元素这一点外会快一点<br>//参考：<a href="https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist">https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist</a><br>peek</p><p>!!!字符串数组 ch.length<br>字符串 s.length()<br>集合类 .size()<br>滑动窗口最大值 双指针不行吗</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/06/06/Notes/"/>
    <url>/2022/06/06/Notes/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="判断对象”生死“"><a href="#判断对象”生死“" class="headerlink" title="判断对象”生死“"></a>判断对象”生死“</h3><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>应用计数法–循环引用问题–&gt;可达性分析算法<br>实现：通过一系列GC Roots通过引用链。当Object到GC Roots不可达则需回收</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>强引用、软引用、若引用、虚引用</p><h4 id="方法区-无用的类"><a href="#方法区-无用的类" class="headerlink" title="方法区-无用的类"></a>方法区-无用的类</h4><p>ps: 元空间–永久代–方法区落地实现<br>所有实例已被回收（Java堆中不存在该类实例）<br>加载该类的ClassLoader已被回收<br>该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h4><p>不足：<br>效率低–复制算法<br>空间碎片多</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>内存容量等量划分为两块，一次对整个半区进行内存回收<br>只要移动堆顶指针，按顺序分配内存<br>缺点：内存缩小为原来一半（改进1：不均分）<br>对象存活率较高时要进行较多复制操作（改进：标记-整理算法)</p><h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h4><p>不是对可回收对象进行清理，而是让所有存活对象向一端移动，然后清理端边界之外的内存<br>（先挪动，再统一清理）</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>只是根据对象存活周期的不同将内存划分为几块。<br>一般是把Java堆分为新生代和老年代。<br>新生代：每次垃圾收集时都发现有大批对象死去，只有少量存活。<br>选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。<br>老年代：对象存活率高、没有额外空间对它进行分配担保，<br>就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>枚举GC ROOT<br>设判安全点、安全区</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>单线程–收集时暂停其他所有的工作线程 直至收集结束</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>Serial多线程版本</p><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>新生代收集器–使用复制算法<br>关注点<br>CMS等：缩短用户线程停顿时间–响应好<br>Parallel Scanvenge:达到一个可控的吞吐量–高效利用CPU</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>Concurrent Mark Sweep<br>过程：<br>初始标记–&gt;并发标记–&gt;重新标记–&gt;并发清除<br>1、3步需“stop the world”<br>2、4耗时长但可以与用户线程一起工作<br>缺点：<br>对CPU资源敏感<br>无法处理浮动垃圾（并发清理阶段用户线程产生的新垃圾，CMS无法在当次收集中处理掉）<br>基于标记–清除算法 ，会产生大量空间碎片–内存整理仍是单线程</p><h4 id="G1收集器☆"><a href="#G1收集器☆" class="headerlink" title="G1收集器☆"></a>G1收集器☆</h4><p>面向服务端应用<br>初始标记–&gt;并发标记–&gt;最终标记–&gt;筛选回收<br>垃圾收集相关参数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29005494/1653547210249-36327a5b-1805-42ef-a05d-488e5dde67ff.png#clientId=uc173d41e-4a84-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=550&id=u05fa212e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=825&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&size=415424&status=done&style=none&taskId=u08f04b08-62ca-46f6-b9e1-358f7198230&title=&width=577.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29005494/1654276967991-b1262c7a-ce8d-495a-bd1b-b964678f78f9.png#clientId=u34aec54a-525a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u3f4c24f3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100834&status=done&style=none&taskId=u0a6df56e-b014-4ffb-b950-2c5ec0d9d27&title=&width=424.6666666666667" alt="image.png"></p><h2 id="ON-JAVA"><a href="#ON-JAVA" class="headerlink" title="ON JAVA"></a>ON JAVA</h2><p>单继承结构的优势：所有类最终都属于同一个基类；使得垃圾收集器的实现更容易<br>Arrays.asList() 方法接受一个数组或是逗号分隔的元素列表（使用可变参数）， 并将其转换为 **List **对象。但这里底层是数组，尝试在该List上调用add() 或 remove()会在运行时报“Unsupported Operation”<br>Collections.addAll() 方法接受一个 **Collection **对象，以 及一个数组或是一个逗号分隔的列表，将其中元素添加到 **Collection **中。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29005494/1654504936769-e0d64bb1-050d-4dce-915f-645f07ccf78b.jpeg"><br>iterator只能单向移动(hasNext)<br>而ListIterator可以双向移动<br>Queue在LinkedList的基础上添加了element(),offer(),peek(),poll()和remove()方法<br>Java6中添加了ArrayDeque 其中包含直接实现堆栈功能的方法</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
